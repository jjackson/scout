"""
Artifact models for Scout data agent platform.

Artifacts are code/visualization outputs generated by the AI agent, including
React components, HTML pages, Plotly charts, Markdown documents, and SVG graphics.
"""
import hashlib
import secrets
import uuid

from django.conf import settings
from django.core.validators import MinValueValidator
from django.db import models
from django.utils import timezone


class ArtifactType(models.TextChoices):
    """Supported artifact types for the Scout platform."""

    REACT = "react", "React Component"
    HTML = "html", "HTML Document"
    MARKDOWN = "markdown", "Markdown Document"
    PLOTLY = "plotly", "Plotly Chart"
    SVG = "svg", "SVG Graphic"


class Artifact(models.Model):
    """
    Represents a generated artifact from agent conversations.

    Artifacts are code or visualization outputs created by the AI agent during
    conversations. They support versioning through parent_artifact linking and
    can be shared via SharedArtifact records.

    Attributes:
        id: Unique identifier for the artifact.
        project: The project this artifact belongs to.
        created_by: The user who triggered the artifact creation.
        title: Display title for the artifact.
        description: Optional description of what the artifact does/shows.
        artifact_type: Type of artifact (react, html, markdown, plotly, svg).
        code: The source code for the artifact.
        data: Structured JSON data used by the artifact (e.g., chart data).
        version: Version number, incremented when creating new versions.
        parent_artifact: Link to previous version for version tracking.
        conversation_id: Thread ID from the conversation that created this.
        source_queries: List of SQL queries that generated the underlying data.
        created_at: When the artifact was created.
        updated_at: When the artifact was last modified.
    """

    id = models.UUIDField(
        primary_key=True,
        default=uuid.uuid4,
        editable=False,
    )
    project = models.ForeignKey(
        "projects.Project",
        on_delete=models.CASCADE,
        related_name="artifacts",
        help_text="The project this artifact belongs to.",
    )
    created_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="artifacts",
        help_text="User who created this artifact.",
    )
    title = models.CharField(
        max_length=500,
        help_text="Display title for the artifact.",
    )
    description = models.TextField(
        blank=True,
        help_text="Optional description of what this artifact does or shows.",
    )
    artifact_type = models.CharField(
        max_length=20,
        choices=ArtifactType.choices,
        help_text="The type of artifact (react, html, markdown, plotly, svg).",
    )
    code = models.TextField(
        help_text="Source code for the artifact.",
    )
    data = models.JSONField(
        default=dict,
        blank=True,
        help_text="Structured data for the artifact (e.g., chart data, configuration).",
    )
    version = models.IntegerField(
        default=1,
        validators=[MinValueValidator(1)],
        help_text="Version number of this artifact.",
    )
    parent_artifact = models.ForeignKey(
        "self",
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="child_versions",
        help_text="Previous version of this artifact for version tracking.",
    )
    conversation_id = models.CharField(
        max_length=255,
        db_index=True,
        help_text="Thread ID of the conversation that created this artifact.",
    )
    source_queries = models.JSONField(
        default=list,
        blank=True,
        help_text="SQL queries that generated the data for this artifact.",
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ["-created_at"]
        indexes = [
            models.Index(fields=["project", "-created_at"]),
            models.Index(fields=["created_by", "-created_at"]),
        ]
        verbose_name = "Artifact"
        verbose_name_plural = "Artifacts"

    def __str__(self):
        return f"{self.title} (v{self.version})"

    @property
    def content_hash(self) -> str:
        """
        Generate a SHA-256 hash of the artifact's code content.

        Useful for detecting duplicate artifacts or verifying content integrity.

        Returns:
            Hexadecimal string representation of the SHA-256 hash.
        """
        return hashlib.sha256(self.code.encode("utf-8")).hexdigest()

    def create_new_version(self, **updates) -> "Artifact":
        """
        Create a new version of this artifact with the given updates.

        Args:
            **updates: Fields to update in the new version.

        Returns:
            The newly created Artifact instance.
        """
        new_artifact = Artifact(
            project=self.project,
            created_by=updates.get("created_by", self.created_by),
            title=updates.get("title", self.title),
            description=updates.get("description", self.description),
            artifact_type=updates.get("artifact_type", self.artifact_type),
            code=updates.get("code", self.code),
            data=updates.get("data", self.data),
            version=self.version + 1,
            parent_artifact=self,
            conversation_id=updates.get("conversation_id", self.conversation_id),
            source_queries=updates.get("source_queries", self.source_queries),
        )
        new_artifact.save()
        return new_artifact

    def get_version_history(self, max_depth: int = 100) -> list["Artifact"]:
        """
        Get the complete version history of this artifact.

        Args:
            max_depth: Maximum number of parent versions to traverse.
                      Prevents infinite loops if circular references exist.

        Returns:
            List of Artifact instances from oldest to newest version.
        """
        history = [self]
        seen: set[uuid.UUID] = {self.id}
        current = self.parent_artifact
        depth = 0
        while current is not None and depth < max_depth:
            if current.id in seen:
                # Circular reference detected, stop traversal
                break
            seen.add(current.id)
            history.append(current)
            current = current.parent_artifact
            depth += 1
        return list(reversed(history))


class AccessLevel(models.TextChoices):
    """Access level choices for shared artifacts."""

    PUBLIC = "public", "Public (anyone with link)"
    PROJECT = "project", "Project Members Only"
    SPECIFIC = "specific", "Specific Users Only"


class SharedArtifact(models.Model):
    """
    Represents a shareable link to an artifact.

    SharedArtifact enables sharing artifacts with different access levels:
    - Public: Anyone with the link can view
    - Project: Only project members can view
    - Specific: Only explicitly allowed users can view

    Attributes:
        id: Unique identifier for the share record.
        artifact: The artifact being shared.
        created_by: User who created the share link.
        share_token: Unique token for the share URL.
        access_level: Who can access the shared artifact.
        allowed_users: Specific users allowed when access_level is 'specific'.
        expires_at: Optional expiration datetime for the share link.
        view_count: Number of times the shared artifact has been viewed.
        created_at: When the share was created.
    """

    id = models.UUIDField(
        primary_key=True,
        default=uuid.uuid4,
        editable=False,
    )
    artifact = models.ForeignKey(
        Artifact,
        on_delete=models.CASCADE,
        related_name="shares",
        help_text="The artifact being shared.",
    )
    created_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="shared_artifacts",
        help_text="User who created this share link.",
    )
    share_token = models.CharField(
        max_length=64,
        unique=True,
        db_index=True,
        help_text="Unique token for the share URL.",
    )
    access_level = models.CharField(
        max_length=20,
        choices=AccessLevel.choices,
        default=AccessLevel.PROJECT,
        help_text="Who can access this shared artifact.",
    )
    allowed_users = models.ManyToManyField(
        settings.AUTH_USER_MODEL,
        blank=True,
        related_name="accessible_shared_artifacts",
        help_text="Users allowed to access when access_level is 'specific'.",
    )
    expires_at = models.DateTimeField(
        null=True,
        blank=True,
        help_text="When this share link expires. Null means no expiration.",
    )
    view_count = models.IntegerField(
        default=0,
        help_text="Number of times this shared artifact has been viewed.",
    )
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ["-created_at"]
        verbose_name = "Shared Artifact"
        verbose_name_plural = "Shared Artifacts"
        indexes = [
            models.Index(fields=["artifact", "-created_at"]),
        ]

    def __str__(self):
        return f"Share: {self.artifact.title} ({self.access_level})"

    @property
    def share_url(self) -> str:
        """
        Generate the full share URL for this artifact.

        Returns:
            The complete URL path for accessing the shared artifact.
        """
        return f"/artifacts/shared/{self.share_token}/"

    @property
    def is_expired(self) -> bool:
        """
        Check if this share link has expired.

        Returns:
            True if the share has expired, False otherwise.
        """
        if self.expires_at is None:
            return False
        return timezone.now() > self.expires_at

    def increment_view_count(self) -> None:
        """Increment the view count atomically."""
        SharedArtifact.objects.filter(pk=self.pk).update(
            view_count=models.F("view_count") + 1
        )
        self.refresh_from_db(fields=["view_count"])

    def can_access(self, user) -> bool:
        """
        Check if a user can access this shared artifact.

        Args:
            user: The user attempting to access the artifact.

        Returns:
            True if the user can access the artifact, False otherwise.
        """
        if self.is_expired:
            return False

        if self.access_level == AccessLevel.PUBLIC:
            return True

        if user is None or not user.is_authenticated:
            return False

        if self.access_level == AccessLevel.PROJECT:
            # Check if user is a member of the artifact's project
            return self.artifact.project.memberships.filter(user=user).exists()

        if self.access_level == AccessLevel.SPECIFIC:
            return self.allowed_users.filter(pk=user.pk).exists()

        return False

    @classmethod
    def generate_token(cls) -> str:
        """
        Generate a unique share token.

        Returns:
            A URL-safe base64-encoded token (43 characters).
        """
        return secrets.token_urlsafe(32)
